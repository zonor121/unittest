# Структура проекта под `unittest`: как разложить код и тесты, чтобы discovery работал, а импорты не “плавали”

Вы запускаете `python -m unittest` и хотите два результата: **тесты находятся автоматически** и **импорты ведут себя одинаково** на Вашей машине, в IDE и в CI. Когда структура проекта случайная, эти два требования конфликтуют: то `Ran 0 tests`, то `ModuleNotFoundError`, то внезапно импортируется “не тот” модуль с таким же именем.

Эта статья — про один практический навык: **правильно разложить код и тесты**, чтобы `unittest` мог стабильно “собрать” набор тестов через discovery, а Python — стабильно импортировать то, что Вы ожидаете.

## Как `unittest` находит тесты: что именно ему нужно от структуры

В `unittest` discovery — это не “поиск строк `test_`”, а **импорт модулей**, из которых затем извлекаются тест-кейсы. Это важно: если модуль нельзя импортировать, discovery не сможет его запустить. ([Python documentation][1])

Ключевое требование документации можно держать как правило “по умолчанию”:

> “all of the test files must be modules or packages importable from the top-level directory” ([Python documentation][1])

Из этого требования сразу следуют две практические вещи.

Первая — **имена файлов**. Файл теста должен быть валидным именем модуля Python, то есть идентификатором. Дефис в имени (`test-report.py`) ломает импорт. Подчёркивание (`test_report.py`) — корректно. Это прямо указано в документации в контексте “valid identifiers”. ([Python documentation][1])

Вторая — **пакеты и `__init__.py`**. Discovery превращает пути в “dotted names” и импортирует их как пакеты/модули. Пример из документации: `foo/bar/baz.py` будет импортирован как `foo.bar.baz`. ([Python documentation][1])
Если промежуточные директории не являются пакетами (нет `__init__.py`), импорт “как пакет” провалится или discovery вообще не будет искать тесты в таких поддиректориях (это поведение менялось между версиями, но практический вывод один: **для предсказуемости делайте тестовые директории пакетами**). ([Python documentation][1])

Ниже — схема того, что реально происходит во время discovery. Это полезно, потому что позволяет “дедуктивно” отлаживать `Ran 0 tests` и ошибки импорта.

```text
Start directory (-s / start_dir)
        ↓ рекурсивный обход
Файлы, подходящие под pattern (-p, default test*.py)
        ↓ преобразование пути в dotted module name
Импорт модулей (import ...)
        ↓ поиск TestCase и test_* методов
Сборка TestSuite
        ↓
Запуск Runner'ом
```

В документации это сформулировано коротко и жёстко:

> “Test discovery loads tests by importing them.” ([Python documentation][1])

Отсюда важное следствие для структуры: **любая логика на уровне импорта** (выполнение кода в модуле при импортировании) может неожиданно падать и ломать discovery. Поэтому “тяжёлые” действия (подключение к БД, чтение конфигов из сети, запуск сервисов) нельзя делать на верхнем уровне тестового модуля — только внутри тестов или фикстур.

## Команда запуска: почему `-s` и `-t` связаны со структурой

Почти все проблемы с discovery — это не “unittest сломан”, а несоответствие структуры тому, как `discover` строит модульные имена.

Базовый запуск из документации выглядит так:

```bash
cd project_directory
python -m unittest discover
```

И ещё один важный факт: `python -m unittest` без аргументов эквивалентен `python -m unittest discover`. ([Python documentation][1])

Опции, которые напрямую завязаны на структуру:

* `-s` (`--start-directory`) — где искать тесты (по умолчанию `.`). ([Python documentation][1])
* `-p` (`--pattern`) — какие файлы считать тестовыми (по умолчанию `test*.py`). ([Python documentation][1])
* `-t` (`--top-level-directory`) — что считать “корнем проекта” для импортов (по умолчанию совпадает со start directory). ([Python documentation][1])

Почему `-t` важен: документация прямо говорит, что **все тестовые модули должны быть импортируемы от top-level**, и если start directory не является top-level, то top-level нужно указать отдельно. ([Python documentation][1])

Практически это означает: если у Вас тесты лежат в `tests/`, то рабочая команда обычно выглядит так:

```bash
python -m unittest discover -s tests -t .
```

Здесь `-t .` — это “корень проекта” (там, где лежат `src/`, `tests/`, `pyproject.toml`), а `-s tests` — где искать тестовые файлы.

## Почему импорты становятся непредсказуемыми: “flat layout” против “src layout”

Проблема импортов почти всегда возникает из-за того, что Python кладёт **текущую директорию** в начало `sys.path`. В flat-структуре это означает: если в корне репозитория лежит пакет с кодом, он будет импортироваться прямо из рабочей папки, даже если в окружении установлена другая версия этого пакета. Это порождает расхождения “локально работает — в CI иначе”.

Официальный гид по упаковке Python описывает flat и src как два разных подхода к раскладке кода:

* **flat layout**: импортируемые пакеты лежат в корне рядом с конфигами; ([packaging.python.org][2])
* **src layout**: импортируемый код находится в поддиректории `src/`. ([packaging.python.org][2])

Там же перечислены критичные для тестов эффекты:

* src layout **требует установки проекта**, чтобы запускать код (обычно используют editable install для разработки); ([packaging.python.org][2])
* src layout помогает избежать “случайного” импорта кода из рабочей директории, потому что импортируемый пакет отделён от корня проекта. ([packaging.python.org][2])

Эту же мысль прикладно формулирует pyOpenSci: плюс src layout в том, что тесты выполняются против **установленной версии пакета**, а не против файлов в рабочей директории; иначе можно пропустить проблемы, которые проявятся у пользователя после установки. ([pyOpenSci][3])

Для задач QA это напрямую переводится в правило: **если Вы хотите предсказуемые импорты, относитесь к приложению как к пакету и запускайте тесты против установленного пакета** (обычно через `pip install -e .` в виртуальном окружении).

## Две структуры, которые реально работают

Ниже — две раскладки. Обе жизнеспособны. Разница — насколько строго Вы хотите контролировать импорты и насколько проект похож на пакет (а не на “папку со скриптами”).

### Вариант A: flat layout (допустим для небольших проектов)

Python Packaging User Guide определяет flat layout так: код и конфиги на одном уровне. ([packaging.python.org][2])
Real Python приводит flat layout как один из типовых вариантов и подчёркивает, что он проще для небольших проектов, но чаще приводит к “случайным” импортам и хаосу при росте. ([Real Python][4])

Пример:

```text
project_root/
├─ pyproject.toml
├─ myapp/
│  ├─ __init__.py
│  └─ calculator.py
└─ tests/
   ├─ __init__.py
   └─ test_calculator.py
```

Это будет работать с `unittest discover`, если `tests/` и поддиректории — импортируемые пакеты (то есть с `__init__.py`), а имена файлов — валидные идентификаторы. ([Python documentation][1])

### Вариант B: src layout (предпочтителен, если важны “честные” импорты)

Packaging guide формулирует src layout как перенос импортируемого кода в `src/`, чтобы отделить его от корня проекта. ([packaging.python.org][2])
Real Python тоже рекомендует src layout как устойчивый вариант для проектов, где важны корректные импорты и масштабируемость структуры. ([Real Python][4])

Пример:

```text
project_root/
├─ pyproject.toml
├─ src/
│  └─ myapp/
│     ├─ __init__.py
│     └─ calculator.py
└─ tests/
   ├─ __init__.py
   └─ test_calculator.py
```

Смысл src layout в том, что `src/myapp` **не попадает автоматически** в import path только потому, что Вы находитесь в корне проекта. Значит, чтобы `import myapp` работал, пакет нужно установить (обычно в editable режиме). Именно это и делает импорты предсказуемыми. ([packaging.python.org][2])

## Шаблон “под `unittest`”: минимальный проект, который стабильно находится и стабильно импортируется

Ниже — минимальный пример на src layout (как более строгий). Здесь есть всё, что нужно для предсказуемого `unittest discover`: импортируемый пакет, отдельная директория тестов, валидные имена модулей, отсутствие “магии” с `sys.path`.

### 1) Код приложения

`src/myapp/calculator.py`

```python
def divide(a: float, b: float) -> float:
    if b == 0:
        raise ValueError("division by zero")
    return a / b
```

`src/myapp/__init__.py` (может быть пустым)

```python
# package marker
```

### 2) Тесты

`tests/test_calculator.py`

```python
import unittest
from myapp.calculator import divide

class TestDivide(unittest.TestCase):
    def test_divides_numbers(self):
        self.assertEqual(divide(10, 2), 5)

    def test_raises_on_zero_division(self):
        with self.assertRaises(ValueError):
            divide(1, 0)

if __name__ == "__main__":
    unittest.main()
```

`tests/__init__.py` (пустой файл, но важный)

```python
# makes tests a regular package
```

Почему `tests/__init__.py` здесь не “для красоты”: discovery превращает пути в dotted names и импортирует их. Если `tests` не пакет, `tests.test_calculator` не импортируется как модуль, и discovery ломается. ([Python documentation][1])

### 3) Установка в editable режиме (для src layout)

Факт из packaging guide: src layout требует установки проекта, иначе импортируемый код не доступен напрямую. ([packaging.python.org][2])
Практически это делается так (внутри виртуального окружения):

```bash
python -m pip install -e .
```

### 4) Запуск discovery

Из корня проекта:

```bash
python -m unittest discover -s tests -t .
```

Опции `-s/-t` и дефолтный pattern `test*.py` — это стандартные параметры `discover`, описанные в документации `unittest`. ([Python documentation][1])

## Тонкие места discovery, которые лучше закрыть сразу

### Директории без `__init__.py` могут быть “невидимыми”

В документации отмечены изменения поведения discovery между версиями Python: была поддержка namespace packages, затем её убирали, затем возвращали, и при этом отдельно оговорено, что тесты не ищутся в поддиректориях без `__init__.py` (чтобы не сканировать “не-Python” директории). ([Python documentation][1])

Практический вывод без привязки к конкретной версии: **если тесты лежат в поддиректориях, добавляйте `__init__.py` в каждую директорию по пути**. Тогда импорт и discovery остаются регулярными и понятными.

### Discovery импортирует модули. Любой код на уровне импорта будет выполнен

Это прямое следствие фразы “loads tests by importing them”. ([Python documentation][1])
Если тестовый файл делает что-то “тяжёлое” на верхнем уровне (например, читает секреты, открывает сокет), это может ломать discovery ещё до запуска тестов. Хорошая структура проекта помогает, но дисциплина импорта — обязательна.

### Конфликт имён с глобально установленными пакетами

В документации есть предупреждение: если у Вас есть пакет, установленный глобально, и Вы запускаете discovery по другой копии с тем же именем, импорт может произойти “не оттуда”. В этом случае discovery может предупредить и завершиться. ([Python documentation][1])

Это ещё один аргумент в пользу src layout + виртуального окружения: Вы намеренно управляете тем, что установлено и что импортируется.

## Быстрая диагностика: типовые симптомы и что они означают для структуры

| Симптом                                                  | Что это почти всегда значит                                                    | Что исправлять                                                                                                                                 |
| -------------------------------------------------------- | ------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| `Ran 0 tests`                                            | discovery не нашёл файлов по pattern или не смог импортировать найденные тесты | проверьте `-s/-p/-t`, имена `test*.py`, наличие `__init__.py` в тестовых директориях ([Python documentation][1])                               |
| `ModuleNotFoundError: No module named 'myapp'`           | пакет приложения не на `sys.path`                                              | для src layout — сделайте `pip install -e .`; для flat — проверьте, что запускаете из корня и что `myapp/` — пакет ([packaging.python.org][2]) |
| `ImportError: Failed to import test module ...`          | тестовый модуль найден, но не импортируется как модуль/пакет                   | проверьте валидность имени файла (идентификатор), `__init__.py`, отсутствие сайд‑эффектов при импорте ([Python documentation][1])              |
| Тесты “проходят локально”, но падают в CI из‑за импортов | импортируется не та копия кода (рабочая папка vs установленный пакет)          | используйте src layout и запуск против установленного пакета ([packaging.python.org][2])                                                       |

## Заключение: структура — это часть тестируемости

`unittest` discovery предъявляет к проекту конкретные требования: тесты должны быть импортируемыми модулями/пакетами от top-level, имена файлов должны быть валидными идентификаторами, а найденные тесты загружаются через импорт. ([Python documentation][1])
Если Вы фиксируете структуру (пакет с кодом, отдельная директория тестов, `__init__.py` в тестовых директориях, корректные имена файлов, запуск из корня с правильными `-s/-t`), то “магия discovery” превращается в прозрачный и управляемый механизм.

Для предсказуемых импортов наиболее надёжный путь — **src layout + запуск тестов против установленного пакета**: он уменьшает вероятность “случайно импортировали не то” и делает окружения ближе к тому, как код будет работать после установки. ([packaging.python.org][2])

## Дополнительные материалы

Официальная документация Python `unittest`: раздел Test Discovery (правила импортируемости, `-s/-p/-t`, предупреждения про импорт). ([Python documentation][1])
Python Packaging User Guide: “src layout vs flat layout” (отличия, влияние текущей директории на импорт). ([packaging.python.org][2])
pyOpenSci: “The src layout and testing” (почему src layout помогает тестировать установленную версию). ([pyOpenSci][3])
Real Python (reference): “project layout” (типовые структуры `src/`, `tests/`, причины выбирать ту или иную). ([Real Python][4])

[1]: https://docs.python.org/3/library/unittest.html "unittest — Unit testing framework — Python 3.14.3 documentation"
[2]: https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/ "src layout vs flat layout - Python Packaging User Guide"
[3]: https://www.pyopensci.org/python-package-guide/package-structure-code/python-package-structure.html "Python Package Structure & Layout — Python Packaging Guide"
[4]: https://realpython.com/ref/best-practices/project-layout/ "project layout | Python Best Practices – Real Python"
