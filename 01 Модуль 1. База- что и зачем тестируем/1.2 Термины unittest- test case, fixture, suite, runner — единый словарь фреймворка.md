# `unittest` без магии: что такое test case, fixture, suite и runner — и как они вместе запускают Ваши тесты

Вы написали первый автотест, запускаете `python -m unittest` и видите что‑то вроде `Ran 3 tests … OK`. Или, хуже, `Ran 0 tests`. На этом месте у начинающих QA обычно возникает одна и та же проблема: **непонятно, что именно считается “тестом”, кто его собирает, кто запускает, и где живёт подготовка данных**. Пока эти термины не разложены по полочкам, отладка тестов превращается в угадайку.

В `unittest` четыре базовых понятия описывают практически всё, что происходит при запуске: **test case**, **test fixture**, **test suite**, **test runner**. В официальной документации они определены прямо в начале, потому что это каркас фреймворка. ([Python documentation][1])

Ниже — “карта местности” для новичка: что означает каждый термин, как он выглядит в коде и как по ним понимать поведение тестов при запуске.

## Короткая карта: кто кем управляет

Представьте, что запуск тестов — это конвейер.

* **Runner** (раннер) управляет процессом запуска и выдаёт результат пользователю.
* Runner запускает **Suite** (набор), то есть коллекцию тестов.
* Suite содержит **Case** (кейсы), то есть отдельные сценарии.
* Каждый case исполняется в своём окружении — это **Fixture** (фикстура): подготовка перед тестом и уборка после.

В `unittest` это не метафора, а реальная объектная модель: раннеру можно передать suite или case, suite “ведёт себя как тест”, а подготовка и очистка встроены в жизненный цикл `TestCase`. ([Python documentation][1])

Ниже схема (как инфографика, но текстом):

```text
┌─────────────────────────────┐
│ Test Runner (unittest.main   │
│  / TextTestRunner)           │
└──────────────┬──────────────┘
               │ run(test)
               ▼
┌─────────────────────────────┐
│ Test Suite (TestSuite)       │  ← агрегирует тесты
└──────────────┬──────────────┘
               │ iterates
               ▼
┌─────────────────────────────┐
│ Test Case (TestCase instance)│  ← один сценарий (обычно один test_* метод)
└──────────────┬──────────────┘
               │ around the test
               ▼
┌─────────────────────────────┐
│ Fixture (setUp/tearDown,     │  ← подготовка/очистка
│  cleanups)                   │
└─────────────────────────────┘
```

Если Вы понимаете эту цепочку, то большинство “странностей” `unittest` перестают быть странностями.

## Test case: что в `unittest` считается “одним тестом”

В документации `unittest` говорится просто: **test case — это отдельная единица тестирования, проверяющая ожидаемый ответ на заданный набор входных данных**. ([Python documentation][1])

Но начинающим важно уточнение: в `unittest` есть **понятие test case как концепт** и есть **класс `unittest.TestCase` как реализация**.

### Концепт: один сценарий

Тест‑кейс в инженерном смысле — это “сценарий”: Вы подготовили входные данные, вызвали систему и проверили результат. Если сценариев много, их должно быть удобно запускать в любом порядке. Поэтому `unittest` подчёркивает, что код теста должен быть самодостаточным и запускаться изолированно или в любой комбинации с другими тестами. ([Python documentation][1])

### Реализация: `unittest.TestCase` и методы `test_*`

В `unittest` Вы создаёте тест‑кейс, наследуясь от `unittest.TestCase`. А отдельные тесты внутри — это методы, имя которых начинается с `test`. Это соглашение — сигнал тест‑раннеру, какие методы считать тестами. ([Python documentation][1])

Важно увидеть здесь “единицу исполнения”: **фреймворк запускает не класс целиком как одну проверку, а каждый `test_*` метод как отдельный тест**. Именно поэтому Вы видите `Ran N tests` — N обычно равно количеству `test_*` методов (с учётом `subTest`, пропусков и т.п.).

Вот минимальный пример “test case” в смысле `unittest`:

```python
import unittest

class TestStringRules(unittest.TestCase):
    def test_uppercase(self):
        self.assertEqual("qa".upper(), "QA")

    def test_split(self):
        self.assertEqual("a b".split(), ["a", "b"])

if __name__ == "__main__":
    unittest.main()
```

Технически: экземпляры `TestCase` — это “логические единицы тестирования” в мире `unittest`, и они реализуют интерфейс, который нужен тест‑раннеру, чтобы “вести” тест (запускать, фиксировать результат). ([Python documentation][1])

## Fixture: подготовка и “уборка” вокруг теста

В документации `unittest` **test fixture** определена как подготовка, нужная для выполнения теста(ов), и связанная с ней очистка. Примеры из документации: временные/прокси БД, директории, запуск серверного процесса. ([Python documentation][1])

В реальной жизни QA это означает: “создать объект системы под тестом, подготовить данные, открыть ресурс; после теста — закрыть ресурс, удалить временное, вернуть состояние”.

### Главная деталь, которую чаще всего не знают новички

`unittest` делает важное утверждение: **для каждого отдельного `test_*` метода создаётся новый экземпляр `TestCase` как уникальная фикстура**, и, следовательно, `TestCase.__init__()`, `setUp()` и `tearDown()` вызываются *один раз на тест*. ([Python documentation][1])

Это влияет на Ваши ожидания:

* Если в `setUp()` Вы создаёте объект, он **не будет общим** для всех тестов класса — он будет свежим для каждого метода.
* Если Вы “копите” состояние в `self` и надеетесь, что другой тест увидит это состояние — Вы получите нестабильность или просто непонимание, почему “не работает”.

Эту модель полезно держать в голове как таймлайн:

```text
для каждого test_* метода:

TestCase.__init__()  →  setUp()  →  test_method()  →  tearDown()  →  cleanups
```

`setUp()` и `tearDown()` описаны в документации как методы, выполняемые до и после каждого тест‑метода. ([Python documentation][1])

### “Фикстура” ≠ “тестовые данные”

Слово fixture многие путают с “набором тестовых данных”. В `unittest` fixture — это шире: **это рабочее окружение** (объекты, ресурсы, подготовленные внешние условия) плюс очистка. Данные могут быть частью фикстуры, но не обязаны быть её единственным содержимым. ([Python documentation][1])

### Код: фикстура с `setUp()` и гарантированной очисткой через `addCleanup()`

Новички часто пишут очистку только в `tearDown()` и забывают про ситуации, когда `setUp()` упал на середине. В `unittest` есть механизм cleanup‑ов, которые выполняются даже если `setUp()` не завершился корректно (в отличие от `tearDown`, который логически зависит от успешного setup). В базовой документации много внимания уделено “фикстуре как окружению” и жизненному циклу, а сами cleanup‑механизмы описаны в API `TestCase`. ([Python documentation][1])

Практический пример (всё стандартной библиотекой): создаём временную директорию, записываем файл, гарантируем очистку.

```python
import os
import tempfile
import unittest

def read_first_line(path: str) -> str:
    with open(path, "r", encoding="utf-8") as f:
        return f.readline().rstrip("\n")

class TestReadFirstLine(unittest.TestCase):
    def setUp(self):
        # Fixture: временная директория
        self._tmpdir = tempfile.TemporaryDirectory()
        # addCleanup гарантирует очистку даже если тест упадёт
        self.addCleanup(self._tmpdir.cleanup)

        self.file_path = os.path.join(self._tmpdir.name, "data.txt")
        with open(self.file_path, "w", encoding="utf-8") as f:
            f.write("hello\nworld\n")

    def test_reads_first_line(self):
        self.assertEqual(read_first_line(self.file_path), "hello")

if __name__ == "__main__":
    unittest.main(verbosity=2)
```

Здесь Вы видите связку: **test case** (метод `test_reads_first_line`) исполняется внутри **fixture** (`setUp` + cleanup).

## Suite: как тесты группируются и “собираются” в запуск

В определении `unittest`: **test suite — коллекция test case, test suite или и того и другого; используется, чтобы агрегировать тесты, которые должны быть выполнены вместе**. ([Python documentation][1])

На уровне реализации это `unittest.TestSuite`. В документации отдельно подчёркнуто: suite “похожа” на case по интерфейсу (её тоже можно “запустить”), но она не реализует тест, а лишь агрегирует тесты в группы. ([Python documentation][1])

### Почему QA‑инженеру вообще важно понимать suite

Потому что suite отвечает на вопросы вида:

* “Почему запускаются не все тесты?”
* “Почему запускается сначала один модуль, потом другой?”
* “Как запустить только часть тестов, но не по имени файла?”
* “Почему мои `setUpClass`/`setUpModule` сработали странно?”

Даже если Вы никогда не создадите `TestSuite` руками, **она всё равно существует**, потому что discovery/loader собирает найденные тесты именно в suite. Документация прямо говорит: механизм группировки тестов — это test suite, а `unittest.main()` “обычно сделает правильную вещь” и соберёт кейсы за Вас. ([Python documentation][1])

### Ключевой момент: suite — это “контейнер”, который раннер умеет запускать

В типичном сценарии Вы запускаете тесты через CLI (`python -m unittest`) или `unittest.main()`. Внутри происходит примерно следующее: loader находит `TestCase`‑классы и их `test_*` методы, упаковывает их в suite и передаёт раннеру. Часть этого пути показана прямо в документации (пример `suite()` + `TextTestRunner().run(suite())`). ([Python documentation][1])

### Код: ручная сборка suite (чтобы увидеть механизм)

Это не “обязательный стиль”, но это отличный учебный пример. Вы увидите руками: suite содержит тесты, runner запускает suite.

```python
import unittest

def add(a, b):
    return a + b

class TestAdd(unittest.TestCase):
    def test_adds_positive(self):
        self.assertEqual(add(2, 3), 5)

    def test_adds_negative(self):
        self.assertEqual(add(-2, 3), 1)

def suite():
    s = unittest.TestSuite()
    # Добавляем конкретные тест-методы (каждый — отдельный TestCase instance)
    s.addTest(TestAdd("test_adds_positive"))
    s.addTest(TestAdd("test_adds_negative"))
    return s

if __name__ == "__main__":
    runner = unittest.TextTestRunner(verbosity=2)
    runner.run(suite())
```

Документация описывает `TestSuite` именно так: она принимает итерабельный набор тестов и имеет методы `addTest/addTests`, а запускается через `run(result)` обычно “по инициативе TestRunner”. ([Python documentation][1])

## Runner: кто реально запускает тесты и показывает результат

По определению `unittest`: **test runner — компонент, который оркестрирует выполнение тестов и предоставляет результат пользователю**. Это может быть текстовый интерфейс, графический или просто возвращаемое значение. ([Python documentation][1])

В стандартной библиотеке “базовый” раннер — `unittest.TextTestRunner`. Документация подчёркивает его свойства: он выводит результаты в поток (по умолчанию `sys.stderr`), создаёт `TestResult`, запускает переданный suite/case и печатает отчёт. ([Python documentation][1])

Отсюда практический вывод: когда Вы запускаете тесты через `unittest.main()`, Вы фактически используете раннер (по умолчанию текстовый), просто не создаёте его вручную. Документация описывает `unittest.main()` как командную программу, которая загружает набор тестов из модуля и запускает их. ([Python documentation][1])

### Runner и “результат”: почему в отчёте есть failures и errors

Раннер аккумулирует данные в объекте `TestResult` и затем печатает summary. В документации отмечено, что фреймворки поверх `unittest` могут хотеть доступ к `TestResult` для отчётности, и `TestRunner.run()` возвращает `TestResult`. ([Python documentation][1])

Для новичка это полезно так: если Вы пишете свой “мини‑раннер” (например, для запуска smoke‑набора), Вы можете программно проверить `result.wasSuccessful()` и выставить exit code.

### Код: свой запуск suite через runner и корректный exit code

```python
import sys
import unittest

class TestSomething(unittest.TestCase):
    def test_ok(self):
        self.assertTrue(True)

def suite():
    return unittest.defaultTestLoader.loadTestsFromTestCase(TestSomething)

if __name__ == "__main__":
    runner = unittest.TextTestRunner(verbosity=2, failfast=False)
    result = runner.run(suite())
    sys.exit(0 if result.wasSuccessful() else 1)
```

Здесь появляется ещё один термин — loader, но он лишь “сервисная часть”: `TestLoader` создаёт suite из модулей/классов; по умолчанию доступен `unittest.defaultTestLoader`. ([Python documentation][1])

## Одна таблица, чтобы закрепить термины

| Термин        | Что это “по смыслу”                  | Что это в `unittest`                                    | Что Вы делаете руками чаще всего                                                                                              |
| ------------- | ------------------------------------ | ------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| **test case** | Один сценарий проверки               | `unittest.TestCase` + `test_*` методы                   | Пишете `class ... (unittest.TestCase)` и методы `test_*` ([Python documentation][1])                                          |
| **fixture**   | Подготовка/очистка окружения         | `setUp/tearDown`, cleanups; также class/module fixtures | Настраиваете `setUp` и освобождаете ресурсы после теста ([Python documentation][1])                                           |
| **suite**     | Коллекция тестов, запускаемая вместе | `unittest.TestSuite`                                    | Обычно не создаёте вручную, но используете через discovery/loader; иногда собираете “smoke suite” ([Python documentation][1]) |
| **runner**    | Оркестратор запуска и репорта        | `unittest.TextTestRunner`, `unittest.main()`            | Запускаете через CLI или `unittest.main()`; реже — вручную для кастомного сценария ([Python documentation][1])                |

## Типовые “симптомы” и как термины помогают их лечить

Если Вы видите, что `setUp()` вызывается “слишком много раз”, почти всегда причина в том, что **каждый `test_*` метод — отдельный case**, и под него создаётся новый `TestCase`‑инстанс как уникальная фикстура. Это ожидаемое поведение. ([Python documentation][1])

Если Вы получили `Ran 0 tests`, думайте в терминах сборки suite: **loader/discovery не нашёл test cases**, а значит не смог собрать suite, который runner должен запускать. Документация описывает правила discovery (например, что тестовые файлы должны быть импортируемыми модулями/пакетами и соответствовать паттерну). ([Python documentation][1])

Если тесты “влияют друг на друга”, это обычно означает, что фикстура нарушает изоляцию: Вы вынесли состояние на уровень класса/модуля или используете общий ресурс без корректной очистки. Документация подчёркивает самодостаточность `TestCase` и возможность запуска в произвольной комбинации. ([Python documentation][1])

## Заключение: одна модель, к которой Вы будете возвращаться

Запуск `unittest` можно воспринимать как четыре слоя, и каждый отвечает на свой вопрос:

**Test case** — что конкретно проверяется в одном сценарии. ([Python documentation][1])
**Fixture** — в каком окружении сценарий выполняется и как оно очищается. ([Python documentation][1])
**Suite** — какие сценарии объединены в один запуск. ([Python documentation][1])
**Runner** — кто запускает suite и как Вы видите результат. ([Python documentation][1])

Если Вы держите эту модель в голове, то “почему оно так работает” и “как мне запустить/отладить” решается не догадками, а чтением происходящего через правильные термины.

## Дополнительные материалы

Официальная документация `unittest` (определения терминов, жизненный цикл, suite/runner). ([Python documentation][1])
Раздел “Organizing test code” в документации (self‑contained тесты, setUp/tearDown, пример suite + runner). ([Python documentation][1])
Обзорный материал Real Python по `unittest` (те же термины, объяснение практического смысла). ([realpython.com][2])

[1]: https://docs.python.org/3/library/unittest.html "unittest — Unit testing framework — Python 3.14.3 documentation"
[2]: https://realpython.com/python-unittest/ "Python's unittest: Writing Unit Tests for Your Code – Real Python"
