# Независимость тестов в `unittest`: как писать автотесты, которые запускаются по одному и в любом порядке

Вы запускаете один тест — он проходит. Запускаете весь набор — внезапно падение. Затем меняете имя метода или добавляете новый тест, и падает уже другой. Это не «магия фреймворка», а нарушение базового принципа: **каждый тест должен быть независимым**.

Независимость — это практическое требование, а не “красивый идеал”. Оно экономит время на отладке, делает CI предсказуемым и позволяет запускать тесты частями (один модуль, один класс, один метод) без сюрпризов. В `unittest` этот принцип прямо заложен в модель исполнения. ([Python documentation][1])

## Что означает «независимость тестов» в инженерном смысле

В `unittest` есть формулировка, которую стоит воспринимать как контракт:

> “The testing code of a TestCase instance should be entirely self contained … run … in isolation or in arbitrary combination …” ([Python documentation][1])

Переводя на практику QA, это означает сразу несколько вещей.

Тест **не должен полагаться** на то, что до него уже что‑то произошло: кто‑то создал данные, прогрел кеш, изменил переменную окружения, создал файл, настроил глобальную конфигурацию.

Тест **не должен оставлять после себя** изменённое состояние: файл, запись в БД, изменённый `os.environ`, переключённый feature‑flag, изменённый глобальный объект, выставленный seed генератора случайных чисел, подменённую функцию через monkey‑patch.

Тест должен давать одинаковый результат при запуске:

* один тест отдельно;
* произвольная подвыборка тестов;
* полный прогон;
* другой порядок выполнения.

## Как `unittest` запускает тесты и почему это важно для изоляции

`unittest` специально устроен так, чтобы Вам было проще обеспечить независимость, но он не может сделать это «автоматически», потому что Python‑процесс общий для всего прогона, и глобальные состояния никуда не деваются.

### 1) На каждый тестовый метод создаётся отдельный объект `TestCase`

Ключевой факт из документации:

> “A new TestCase instance is created … to execute each individual test method.” ([Python documentation][1])

Это означает: **каждый `test_*` метод выполняется на новом экземпляре класса**, а `setUp()`/`tearDown()` вызываются **один раз на тест**. ([Python documentation][1])

Визуально жизненный цикл одного теста выглядит так:

```text
(создан новый TestCase)
        ↓
setUp()                ← подготовка окружения (fixture)
        ↓
test_*()               ← действие + проверки
        ↓
tearDown()             ← уборка после теста (если setUp() успешен)
        ↓
doCleanups()           ← cleanup-обработчики (срабатывают всегда)
```

Тонкая, но важная деталь: `tearDown()` выполняется только если `setUp()` завершился успешно, а cleanup‑функции выполняются даже если `setUp()` упал. ([Python documentation][1])

### 2) Порядок тестов не является Вашей опорой

По умолчанию `unittest` сортирует тестовые методы по имени:

> “The order … is determined by sorting the test method names …” ([Python documentation][1])

Но это именно «по умолчанию». Порядок может измениться, потому что:

* сравнение имён методов настраивается через `TestLoader.sortTestMethodsUsing`; ([Python documentation][1])
* discovery сортирует пути, чтобы порядок не зависел от файловой системы, и это уже отдельный слой сортировки; ([Python documentation][1])
* тесты могут запускаться частями и в другом группировании (например, по пакетам/модулям). ([Python documentation][1])

Вывод простой: **если тест проходит только в “правильном порядке” — это дефект теста (или дефект границ тестируемого кода).**

## Почему независимость ломается: типовые источники взаимного влияния

Ниже — практическая таблица «симптом → причина → что делать». Это не теория ради теории: это те места, где автотесты реально “заражают” друг друга.

| Где возникает общее состояние                        | Как выглядит симптом                                                         | Что делать в `unittest`                                                                          |
| ---------------------------------------------------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
| Глобальные переменные, синглтоны, модульные кеши     | Тест проходит отдельно, падает в наборе; падение зависит от порядка          | Сбрасывать состояние в `setUp()`/`tearDown()`, избегать глобальных кешей, внедрять зависимости   |
| Файлы/директории с фиксированными именами            | “Файл уже существует”, “не тот контент”, тесты мешают друг другу параллельно | `tempfile.TemporaryDirectory()`, уникальные пути на тест, cleanup                                |
| `os.environ`, глобальная конфигурация, feature‑flags | Один тест включил флаг — другой получил неожиданное поведение                | `patch.dict(os.environ, …)` с автоворотом, не менять `environ` “вручную”                         |
| Время/таймеры/случайность                            | Тест “падает по пятницам”, “иногда падает”                                   | Инъекция “часов”, `patch()` для времени/рандома, фиксировать seed и восстанавливать              |
| Общие фикстуры уровня класса/модуля                  | Неочевидные зависимости между тестами, проблемы при параллельном запуске     | Использовать `setUpClass/setUpModule` осторожно: они ломают изоляцию ([Python documentation][1]) |

Про shared fixtures в документации сказано прямо: они **ломают test isolation** и плохо сочетаются с параллелизацией, поэтому применять их нужно осознанно. ([Python documentation][1])

## Кейс 1. Общая память: тесты “проходят по одному”, но ломаются в наборе

Пусть в коде есть модульный кеш (типичная оптимизация):

```python
# discounts.py
_DISCOUNTS = None

def get_discounts():
    global _DISCOUNTS
    if _DISCOUNTS is None:
        _DISCOUNTS = {"vip": 20, "regular": 0}
    return _DISCOUNTS

def discount_for(level: str) -> int:
    return get_discounts()[level]

def set_discount(level: str, percent: int) -> None:
    get_discounts()[level] = percent
```

Теперь тесты:

```python
# test_discounts.py
import unittest
import discounts

class TestDiscounts(unittest.TestCase):
    def test_default_vip_discount(self):
        self.assertEqual(discounts.discount_for("vip"), 20)

    def test_can_override_discount(self):
        discounts.set_discount("vip", 50)
        self.assertEqual(discounts.discount_for("vip"), 50)

if __name__ == "__main__":
    unittest.main(verbosity=2)
```

Если запустить только `test_default_vip_discount`, он пройдёт. Если запустить весь класс, исход зависит от порядка. По умолчанию `unittest` сортирует методы по имени, но опираться на это нельзя. ([Python documentation][1])

### Исправление через фикстуру: сбрасывать состояние перед каждым тестом

Да, это «грязно», потому что трогается внутреннее состояние модуля. Но как учебная и практическая мера это корректно: тест создаёт и уничтожает своё окружение.

```python
# test_discounts_fixed.py
import unittest
import discounts

class TestDiscounts(unittest.TestCase):
    def setUp(self):
        # Изоляция: возвращаем модуль к исходному состоянию перед каждым тестом
        discounts._DISCOUNTS = None  # осознанно: модульный кеш — источник зависимости

    def test_default_vip_discount(self):
        self.assertEqual(discounts.discount_for("vip"), 20)

    def test_can_override_discount(self):
        discounts.set_discount("vip", 50)
        self.assertEqual(discounts.discount_for("vip"), 50)

if __name__ == "__main__":
    unittest.main(verbosity=2)
```

Именно для этого `unittest` делает новый `TestCase` на каждый тест и вызывает `setUp()`/`tearDown()` на каждый метод: чтобы фикстура была локальной и не “протекала” между тестами. ([Python documentation][1])

Более архитектурный вариант — убрать модульный кеш из логики, сделать явный объект “хранилище скидок” и создавать его заново в `setUp()`. Но даже если код уже написан и кеш нужен, тест обязан **сбросить кеш**.

## Кейс 2. Файлы и директории: независимость рушится из‑за фиксированных путей

Самая частая ошибка — писать в `output.txt` рядом с тестом и надеяться, что “оно само перетрётся”.

Правильная модель: **каждый тест должен иметь собственное временное пространство**.

```python
import os
import tempfile
import unittest

def write_report(dir_path: str, text: str) -> str:
    path = os.path.join(dir_path, "report.txt")
    with open(path, "w", encoding="utf-8") as f:
        f.write(text)
    return path

class TestReports(unittest.TestCase):
    def setUp(self):
        self.tmp = tempfile.TemporaryDirectory()
        # cleanup сработает даже если setUp() упадёт позже
        self.addCleanup(self.tmp.cleanup)

    def test_report_written(self):
        path = write_report(self.tmp.name, "OK")
        with open(path, "r", encoding="utf-8") as f:
            self.assertEqual(f.read(), "OK")

if __name__ == "__main__":
    unittest.main()
```

Почему здесь `addCleanup`, а не только `tearDown`? Потому что `tearDown` вызывается, только если `setUp` успешен, а cleanup‑функции `unittest` гарантирует вызвать даже при падении `setUp`. ([Python documentation][1])

## Кейс 3. Переменные окружения и патчи: изменили — верните обратно

`os.environ` — это глобальное состояние процесса. Любое изменение там влияет на все тесты после. Вместо ручного “запомнил‑вернул” используйте `patch.dict`: он меняет словарь в пределах области и **восстанавливает исходное состояние**. ([Python documentation][2])

```python
import os
import unittest
from unittest.mock import patch

def feature_enabled() -> bool:
    return os.environ.get("FEATURE_X", "0") == "1"

class TestFeatureFlag(unittest.TestCase):
    def test_flag_on(self):
        with patch.dict(os.environ, {"FEATURE_X": "1"}, clear=False):
            self.assertTrue(feature_enabled())
        # после выхода из контекста окружение восстановлено

    def test_flag_off_by_default(self):
        with patch.dict(os.environ, {}, clear=False):
            os.environ.pop("FEATURE_X", None)
            self.assertFalse(feature_enabled())
```

Та же идея работает для патчей функций/классов. `patch()` рассчитан на то, чтобы подмена была ограничена областью теста. ([Python documentation][3])

Особенно полезен приём “patcher в `setUp` + `addCleanup(patcher.stop)`”, потому что `tearDown` может не вызваться при падении `setUp`, а `addCleanup` сработает. Этот сценарий прямо показан в примерах документации `unittest.mock`. ([Python documentation][2])

```python
import unittest
import mymodule
from unittest.mock import patch

class TestWithPatcher(unittest.TestCase):
    def setUp(self):
        self.patcher = patch("mymodule.EXTERNAL_TIMEOUT", 0.01)
        self.addCleanup(self.patcher.stop)
        self.patcher.start()

    def test_something(self):
        self.assertEqual(mymodule.EXTERNAL_TIMEOUT, 0.01)
```

## Кейс 4. Время и случайность: независимость невозможна без детерминизма

Если тест зависит от “текущей даты” или реального `time.time()`, он рано или поздно станет нестабильным. Два рабочих подхода:

1. **Инъекция зависимости** (предпочтительно): код принимает функцию “текущее время” параметром.
2. **Патч**: подменить источник времени через `unittest.mock.patch`.

Ниже патч для примера:

```python
import time
import unittest
from unittest.mock import patch

def is_session_expired(created_at: float, ttl_seconds: int) -> bool:
    return (time.time() - created_at) > ttl_seconds

class TestSessionTTL(unittest.TestCase):
    def test_not_expired(self):
        with patch("time.time", return_value=1_000.0):
            self.assertFalse(is_session_expired(created_at=900.0, ttl_seconds=200))

    def test_expired(self):
        with patch("time.time", return_value=1_200.0):
            self.assertTrue(is_session_expired(created_at=900.0, ttl_seconds=200))
```

Такой тест можно запускать в любом порядке, в любое время суток — и результат не меняется.

## Особая зона риска: `setUpClass` и `setUpModule`

Иногда хочется ускорить прогон и создать дорогой ресурс один раз на класс/модуль. `unittest` это позволяет, но документация предупреждает: **shared fixtures ломают изоляцию** и не дружат с параллелизацией. ([Python documentation][1])

Это не значит “никогда не используйте”. Это значит: используйте, только если выполняются условия:

* ресурс реально дорогой и его создание доминирует время тестов;
* ресурс не хранит изменяемое состояние, либо Вы гарантированно сбрасываете его между тестами;
* Вы понимаете, что при нестандартном порядке выполнения `setUpClass/setUpModule` могут вызываться иначе, чем ожидается. ([Python documentation][1])

Если Вам нужен «дорогой объект» (например, клиент БД), но тестам нужны независимые данные, типичный выход — хранить соединение в `setUpClass`, а транзакции/данные создавать и откатывать на уровне `setUp/tearDown` (или создавать отдельные схемы/таблицы на тест). Механика зависит от технологий, но принцип один: **дорогой ресурс можно шарить, данные и состояние — нельзя**.

## Как быстро проверить, что тесты действительно независимы

Здесь полезны два практических приёма.

Первый — запуск отдельных тестов и поднаборов. `unittest` позволяет запускать модуль, класс или один метод из CLI. ([Python documentation][1]) Если при запуске одиночного метода всё хорошо, а в наборе плохо — это почти всегда утечка состояния между тестами.

Второй — намеренно менять порядок. Поскольку порядок по умолчанию — сортировка имён, его можно “сломать” специально кастомным loader’ом и обнаружить скрытую зависимость. Сам `unittest` показывает, что порядок задаётся загрузчиком и может быть настроен. ([Python documentation][1])

Пример: перемешать методы внутри класса (с фиксированным seed, чтобы воспроизводилось):

```python
import random
import unittest

class RandomOrderLoader(unittest.TestLoader):
    def getTestCaseNames(self, testCaseClass):
        names = super().getTestCaseNames(testCaseClass)
        rnd = random.Random(42)
        rnd.shuffle(names)
        return names

if __name__ == "__main__":
    unittest.main(testLoader=RandomOrderLoader(), verbosity=2)
```

Если после этого “вдруг” появились падения — это не проблема рандома, а сигнал, что тесты завязаны друг на друга.

## Итог

Независимость тестов — это не стиль, а техническое свойство, которое должно сохраняться всегда: тест можно запускать отдельно и в любом сочетании с другими. Это прямо зафиксировано в документации `unittest` как ожидание к `TestCase`, и сама модель исполнения (новый `TestCase` на каждый `test_*`, `setUp/tearDown` на каждый тест) сделана, чтобы Вам было проще держать границы. ([Python documentation][1])

Если тесты влияют друг на друга, почти всегда есть конкретный “канал утечки”: глобальное состояние, внешний ресурс, окружение, время/случайность или shared fixtures. В `unittest` для закрытия этих каналов есть стандартные инструменты: `setUp/tearDown`, `addCleanup`, `tempfile`, `unittest.mock.patch`, `patch.dict`. ([Python documentation][1])

## Дополнительные материалы

Официальная документация `unittest`: модель `TestCase`, `setUp/tearDown`, самодостаточность тестов, порядок выполнения, discovery. ([Python documentation][1])
Раздел про class/module fixtures и предупреждение о том, что shared fixtures ломают изоляцию. ([Python documentation][1])
Официальная документация `unittest.mock` и примеры `patch`, `patch.dict`, `start/stop` + `addCleanup`. ([Python documentation][3])

[1]: https://docs.python.org/3/library/unittest.html "unittest — Unit testing framework — Python 3.14.3 documentation"
[2]: https://docs.python.org/3/library/unittest.mock-examples.html "unittest.mock — getting started — Python 3.14.3 documentation"
[3]: https://docs.python.org/3/library/unittest.mock.html "unittest.mock — mock object library — Python 3.14.3 documentation"
